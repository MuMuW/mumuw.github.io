---
layout: post
title: Java中的强、软、弱、虚引用
categories: Java
description: Java中的强、软、弱、虚引用
keywords: Java, 强、软、弱、虚引用
tags: Java, 强、软、弱、虚引用
---

## 强引用(StrongReference)
> 只要引用存在，垃圾回收器永远不会回收。


> 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 

```
Object obj = new Object();
//可直接通过obj取得对应的对象 如obj.equels(new Object());
而这样 obj对象对后面的new Object有一个强引用，只有当obj这个引用被释放之后,对象才会被释放掉
```
## 软引用(SoftReference)
> 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

> 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

> 非必须引用，内存溢出之前进行回收.

```
参考实现：
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null

这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，
当然，当这个对象被标记为需要回收的对象时，则返回null；

软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，
无需从繁忙的真实来源查询数据，提升速度；
当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。

Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:

软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，

而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。

在回收这些对象之前，我们可以通过:
MyObject anotherRef=(MyObject)aSoftRef.get(); 
重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。
``` 

> 如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:

```
ReferenceQueue queue = new
ReferenceQueue();

SoftReference
ref=new
SoftReference(aMyObject, queue); 

那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，
ref所强引用的SoftReference对象被列入ReferenceQueue

ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。

在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。

如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。

利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。

于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。

SoftReference ref = null;

while ((ref = (EmployeeRef) q.poll()) != null) {

// 清除ref

}
```

## 弱引用(WeakReference)
> 第二次垃圾回收时回收

```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
wf.get();//有时候会返回null
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
```
- 弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
- 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。

- 弱引用与软引用的区别在于：

1. 只具有弱引用的对象拥有更短暂的生命周期。
2. 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
4. 弱引用**可以和一个引用队列（ReferenceQueue）联合使用**，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

## 虚引用(PhantomReference)

> 垃圾回收时回收，无法通过引用取到对象值

```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
```
- 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。
- 虚引用主要用于检测对象是否已经从内存中删除。
虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
- 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用**必须和引用队列 （ReferenceQueue）联合使用**。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

```
ReferenceQueue queue = new ReferenceQueue ();

PhantomReference pr = new PhantomReference (object, queue); 
```

- 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。




