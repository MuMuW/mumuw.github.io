---
layout: post
title: Java对象深入解析
categories: Java
description: 对象，Java，效率
keywords: 对象，Java，效率
tags:  对象，Java，效率

---

> Class 文件包含类的版本、字段、方法、接口、常量池（用于存放编译期生成的各种字面量和符号引用）等描述信息

### 运行时的数据区域

**程序计数器**：

1. 当前线程所执行的字节码的行号指示器。
2. 在任何一个确定时刻，一个处理器都会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都有一个单独的程序计数器，各条线程的程序计数器互不影响，独立存储。
3. 如果线程在执行的是java方法，计数器记录的是征召执行的虚拟机字节码指令的地址。
4. 如果线程在执行的是native方法，计数器值为空。
5. 此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

**Java虚拟机栈**：

1. 虚拟机栈是线程私有的，生命周期与线程相同
2. 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（方法运行时的基础数据结构，储存局部变量表、操作数栈、动态链接等信息，每个方法从调用到执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程）
3. 堆栈中的栈就是虚拟机栈中的变量表部分
4. 线程请求的栈深度大于虚拟机所允许的深度将抛出StackOverflowError异常
5. Java虚拟机栈动态扩展时无法申请到足够的内存时就抛出OutOfMemoryError异常

**本地方法栈**：

1. 为Native方法服务，作用于虚拟机栈相似

**Java堆**：

1. Java堆是虚拟机管理的内存中最大的一块
2. Java堆是被所有线程共享的内存区域
3. 用来存放对象实例，几乎所有的对象实例都在堆中分配
4. Java堆是垃圾收集器管理的主要区域（GC堆）
5. Java堆可以处于物理上的不连续内存空间中，只要逻辑上是连续的就可以
6. 当堆中没有足够空间完成实例分配而且堆也无法再扩展将会抛出OutOfMemoryError异常

**方法区**：

1. 各线程共享的内存区域
2. 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
3. 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

**运行时常量池**：

1. 方法区的一部分
2. 用于在类加载之后存放Class中存放的编译期生成的各种字面量和符号引用
3. 用于存放翻译出来的直接引用
4. 当常量池无法满足内存分配需求时，将抛出OutOfMemoryError异常

**直接内存**：

1. 基于通道与缓冲区的I/O方式
2. 使用Native函数库直接分配堆外内存，通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据




