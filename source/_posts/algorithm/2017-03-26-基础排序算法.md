---
layout: post
title: 基础排序算法
categories: Algorithm
description: 基础排序算法
keywords: 基础排序算法,快速排序,堆排序,冒泡排序
tags: 基础排序算法,快速排序,堆排序,冒泡排序

---

## 复杂度

- 算法复杂度分为时间复杂度和空间复杂度,（算法的复杂性体现在运行该算法时的计算机所需资源的多少上，计算机资源最重要的是时间和空间（即寄存器）资源，因此复杂度分为时间和空间复杂度）。
1. 时间复杂度是指执行算法所需要的计算工作量；
2. 空间复杂度是指执行这个算法所需要的内存空间。
- 计算方法
1. 简单的输入输出语句或赋值语句： 算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数，此类算法的时间复杂度是O(1)。
2. 顺序结构： 需要依次执行一系列语句所用的时间可采用大O下"求和法则"
。

```
求和法则:若算法的2个部分时间复杂度分别为 
T1(n)=O(f(n))和 
T2(n)=O(g(n)),
则T1(n)+T2(n)=O( max( f(n), g(n) ) )

特别地,
若T1(m)=O(f(m)), 
T2(n)=O(g(n)),
则T1(m)+T2(n)=O( f(m) + g(n) )
```


3. 选择结构：如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,检验条件需要O(1)时间
4. 循环结构：循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"
。

```
乘法法则: 是指若算法的2个部分时间复杂度分别为 
T1(n)=O(f(n)),
T2(n)=O(g(n)),
则T1*T2=O( f(n) * g(n) )
```
5. 对于复杂的算法先分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度

```
其余运算法则:
(1)  若g(n)=O(f(n)),
则O(f(n))+ O(g(n))= O(f(n))；

(2)  O(Cf(n)) = O(f(n)),其中C是一个正常数
```
- 常见时间复杂度示例：
1. O(1) ：

```
x=91; y=100;
while(y>0){ 
    if(x>100){
        x=x-10;
        y--;
    } else{
        x++;
    }
}

解答： T(n)=O(1)，总共循环运行了1100次是一个常量
```
 2. O(n^2)

```
sum=0；                    （一次）  
for(i=1;i<=n;i++)          （n+1次）  
   for(j=1;j<=n;j++)       （n^2次）  
    sum++；                （n^2次）

解：因为Θ(2n^2+n+1)=n^2
  （Θ:去低阶项，去掉常数项，去掉高阶项的常参得到），所以T(n)==O(n^2)；
```

```
for (i=1;i<n;i++)  
 {   
     y=y+1;         ①     
     for (j=0;j<=(2*n);j++)      
        x++;        ②        
 } 
 
 解： 语句1的频度是n-1
      语句2的频度是(n-1)*(2^n+1)=2n^2-n-1
      f(n)=2n^2-n-1+(n-1)=2n^2-2；
      又Θ(2n^2-2)=n^2
      该程序的时间复杂度T(n)=O(n^2). 
      
  一般情况下，对步进循环语句只需考虑循环体中语句的执行次数
  忽略该语句中步长加1、终值判别、控制转移等成分，
  当有若干个循环语句时，
  算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。
```
3. O(n) 

```
a=0;  
  b=1;                      ①  
  for (i=1;i<=n;i++)        ②  
  {    
     s=a+b;　　　　③  
     b=a;　　　　　④    
     a=s;　　　　　⑤  
  }  
  解：     语句1的频度：2,        
          语句2的频度： n,        
          语句3的频度： n-1,        
          语句4的频度：n-1,    
          语句5的频度：n-1,                                  
          T(n)=2+n+3(n-1)=4n-1=O(n).
```
4. O(log2^n)

```
i=1;     ①  
while (i<=n)  
  i=i*2; ②  
  
  解：    语句1的频度是1,  
          设语句2的频度是f(n),   
          则：
          2^f(n)<=n;f(n)<=log2n    
          取最大值f(n)=log2n,
          T(n)=O(log2n )
```
5. O(n^3)

```
for(i=0;i<n;i++)  
   {    
      for(j=0;j<i;j++)    
      {  
         for(k=0;k<j;k++)  
            x=x+2;    
      }  
   }  
解：当i=m, j=h的时候,
    内层循环的次数为h
    当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次
    所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6
    所以时间复杂度为O(n3).
```




 


## 冒泡排序
- 最差时间复杂度O（n^2）
- 最优时间复杂度O（n）
- 平均时间复杂度O（n^2）
- 空间复杂度 总共O(n)，需要辅助空间O(1)
- 实现原理
1. 第一个数与第二个数进行比较交换大的置后，第二个与第三个比较交换，一直进行到第n-1个数。
2. 从第一个数开始继续按1的方法进行交换到n-2个数
3. 重复循环1、2直到数列有序

```
public class HelloWorld {
	public static void main(String[] args) {
		int A [] = {1,3,2,4,5,3,7,6};
		bubble(A);
		for (int i = 0;i<A.length;i ++){
		    System.out.println(A[i]);
		}
	}
	
	public static void bubble(int A[]){
	    int len = A.length;
	    for (int i = 0; i < len - 1; i ++){
	        boolean ordered = true;
	        for(int j = 0; j < len - i - 1; j ++ ){
	            if(A[j] > A[j+1]){
	                ordered = false;
	                A [j] ^= A[j+1];
	                A [j+1] ^= A[j];
	                A [j] ^= A[j+1];
	            }
	        }
	        if(ordered){
	            break;
	        }
	    }   
	}
}
```
## 选择排序(直接选择)
- 最差时间复杂度O（n^2）
- 最优时间复杂度O（n^2）
- 平均时间复杂度O（n^2）
- 辅助空间O（1）
- 实现原理
1. 从所有n-i+1个数（Ri,Ri+1,…,Rn）中找出排序码最小（或最大）的记录，与第i个记录交换。执行n-1趟 后就完成了记录序列的排序。

```
public class HelloWorld {
	public static void main(String[] args) {
		int A [] = {1,3,2,4,5,3,7,6};
		select(A);
		for (int i = 0;i<A.length;i ++){
		    System.out.println(A[i]);
		}
	}
	
	public static void select(int A[]){
	    int len = A.length;
	    for (int i = 0; i < len - 1 ; i ++){
	        int index = i;
            for (int j = i + 1; j< len; j ++ ){
                if (A[index] > A [j]){
                    index = j;
                }
            }
            if(index != i){
                A[i] ^= A[index];
                A[index] ^= A[i];
                A[i] ^= A[index];
            }
	    }   
	}
}
```

## 插入排序

- 最差时间复杂度O（n^2）
- 最优时间复杂度O（n）
- 平均时间复杂度O（n^2）
- 辅助空间O（1）
- 实现原理

1. 将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序,是稳定的排序方法。
2. 插入排序又分为直接插入排序和折半插入排序

```
public class HelloWorld {
	public static void main(String[] args) {
		System.out.println("Hello,Java world of AnycodeX!");
		int data [] = {3,4,2,1,5,6,8,7};
	    insert(data,8);
	    for(int i = 0;i < 8; i ++){
	        System.out.println(data[i]);
	    }
	    
	}
	public static void insert(int [] data,int length){
	    for(int i = 1;i <= length - 1; i ++){   //i is the index to insert 2,4,1,5,6,8,7
	        int j = i;
	        int temp = data [i];
	        while(j > 0 && data[j-1] > temp){
	            data [j] = data[j - 1];
	            j --;
	        }
	        data [j] = temp;
	    }
	}
}
```

## 归并排序

- 最差时间复杂度O（n^2）
- 最优时间复杂度O（n）
- 平均时间复杂度O（n^2）
- 辅助空间O（1）
- 实现原理






