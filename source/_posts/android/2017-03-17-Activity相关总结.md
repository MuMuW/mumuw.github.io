---
layout: post
title: Activity相关总结
categories: Android
description: Activity相关总结
keywords: Android, 生命周期, 启动模式
tags: Android, 生命周期, 启动模式
header-img: "/img/article_header/article_header.png"
catalog: true
toc_nav_num: true


---


### 生命周期图解


![activity](/assets/images/android/activity_lifecycle.png)

- Activity全部都归属于task管理，task 是多个 activity 的集合，这些 activity 按照启动顺序排队存入一个栈（即“back stack”）。android默认会为每个App维持一个task来存放该app的所有activity，task的默认name为该app的packagename。
- 自定义task：在AndroidMainfest.xml中申明activity的taskAffinity属性
### 调用过程

- 打开Activity：onCreate（） -> onStart() -> onResume() 然后开始running
- running的时候被覆盖了（从它打开了新的activity或是被锁屏，但是它依然在前台运行， lost focus but is still visible），系统调用onPause();
- onPause（）：该方法执行activity暂停，通常用于提交未保存的更改到持久化数据，停止动画和其他的东西。但这个activity还是完全活着（它保持所有的状态和成员信息，并保持连接到窗口管理器）
- 接下来它有三条出路
- ①用户返回到该activity就调用onResume()方法重新running

- ②用户回到桌面或是打开其他activity，就会调用onStop()进入停止状态（保留所有的状态和成员信息，对用户不可见）

- ③系统内存不足，拥有更高限权的应用需要内存，那么该activity的进程就可能会被系统回收。（回收onPause()和onStop()状态的activity进程）要想重新打开就必须重新创建一遍。
- 如果用户返回到onStop()状态的activity（又显示在前台了），系统会调用
onRestart() -> onStart() -> onResume() 然后重新running
- 在activity结束（调用finish ()）或是被系统杀死之前会调用onDestroy()方法释放所有占用的资源。

- activity的完整生存期会在 onCreate() 调用和 onDestroy() 调用之间发生。　
- activity的可见生存期会在 onStart() 调用和 onStop() 调用之间发生。系统会在activity的整个生存期内多次调用 onStart() 和onStop()， 因为activity可能会在显示和隐藏之间不断地来回切换。　
- activity的前后台切换会在 onResume() 调用和 onPause() 之间发生。 因为这个状态可能会经常发生转换，为了避免切换迟缓引起的用户等待，这两个方法中的代码应该相当地轻量化。
## onSaveInstanceState
- 　在activity可能被回收之前调用,用来保存自己的状态和信息，以便回收后重建时恢复数据（在onCreate()或onRestoreInstanceState()中恢复）
- 　调用就一定发生在onStop方法之前，但并不保证发生在onPause的前面还是后面。
## onRestoreInstanceState
- 在onStart 和 onPostCreate之间调用，在onCreate中也可以状态恢复，但有时候需要所有布局初始化完成后再恢复状态。
- onPostCreate：一般不实现这个方法，当程序的代码开始运行时，它调用系统做最后的初始化工作。
## 启动模式

1. 打开一个新的ActivityB时生命周期：

```
 ActivityA ：onPause()
 ActivityB ：onCreate()
 ActivityB ：onStrart()
 ActivityB ：onResume()（不能做耗时操作）
 ActivityA ：onStop() （B若是透明主题则不执行）
```
2. Activity启动模式
- 标准模式：standard

```
1. 每次启动都会创建一个新的实例，不管这个实例是否存在。
2. 谁启动了这个Activity那么这个Activity就运行在启动它的那个Activity栈中。
3. 使用ApplicationContext启动Standard模式的Activity会报错，因为非Activity类型的Context没有任务栈。

```
- 栈顶复用模式：singleTop

> Flag : FLAG_ACTIVITY_SINGLE_TOP

 ```
1. 如果新的Activity已经位于任务栈的栈顶则不会再创建新的Activity实例，而是调用其onNewIntent()。
2. 如果新的Activity已存在但是不位于栈顶，则新的Activity会重新创建。

 ```
- 栈内复用模式：singleTask

> Flag : FLAG_ACTIVITY_NEW_TASK

```
1. 只要Activity在一个栈中存在，那多次启动此Activity都不会重新创建实例，而是调用其onNewIntent()。
2. 当启动ActivityA时，系统会先寻找是否存在A想要的任务栈，不存在则创建一个新的任务栈，然后创建A实例并把其放入栈中。如果存在则把A调到栈顶（clearTop）并调用其newIntent()方法，如果不存在则创建A的实例并压入栈中。

```
- 单实例模式：singleInstance

```
1. 具有singleTask的所有特性，而且只能单独的位于一个任务栈中。
2. 当启动ActivityA时系统为其创建一个新的任务栈，然后A独自在这个新的任务栈中，后续的请求均不会创建新的Activity除非这个独特的任务栈被销毁了。
```
3. TaskAffinity(任务相关性)

> 标识一个Activity所需的任务栈的名字，默认情况下所有Activity所需的任务栈的名字为应用的包名。

> 为Activity单独指明的TaskAffinity属性值不能与包名相同，否则就相当于没有指定。

> TaskAffinity主要与singleTask配对使用，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中。

> TaskAffinity与allowTaskReparenting使用，
当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性为true的话，当应用B被启动后，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。(http://blog.csdn.net/new_abc/article/details/13730413)

3. Activity的Flags

- FLAG_ACTIVITY_CLEAR_TOP : 启动时在同一个任务栈中所有位于它上面的Activity都要出栈。
- FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS : 使Activity不出现在历史Activity的列表中。
