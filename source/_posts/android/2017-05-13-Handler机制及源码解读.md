---
layout: post
title: Handler机制及源码解读
categories: Android
description: Handler机制
keywords: Android, Handler，Looper，MessageQueue
tags: Android, Handler，Looper，MessageQueue

---

## Handler、MessageQueue、Looper关系概述

![handler_loope](/assets/images/handler_looper-1.png)


> Runnable 和 Message 可以被压入某个MessageQueue中形成一个集合

> Looper循环的从MessageQueue中取出item传递给Handler

> Handler真正的处理消息

#### 总结

1. 每个Thread只对应一个Looper
2. 每个Looper只对应一个MessageQueue
3. 每个MessageQueue中有N个Message
4. 每个Message中最多指定一个Handler来处理事件


## Handler

### 作用

1. 处理Message
2. 将Message压入MessageQueue


```
类：

public class Handler{
    final MessageQueue mQueue;
    final Looper mLooper;
    final Callback mCallback;
}

```


```
构造函数：

public Handler(Callback callback, boolean async) {
        
        ... ...
        
        mLooper = Looper.myLooper();        //sThreadLocal.get() 获取该Thread的Looper对象赋值给Handler里的Looper变量，每个Thread只有一个Looper对象
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;            //拿Looper里的MessageQueue对象赋值给Handler里的MessageQueue变量
        mCallback = callback;
        mAsynchronous = async;
    }

```
##### 处理message

> Looper 从MessageQueue里取出message后先调用Handler.dispatchMessage进行消息分发

```
分发事件：

    /**
     * Handle system messages here.
     */
    public void dispatchMessage(Message msg) {
        if (msg.callback != null) { //先判断message里是否有callback
            handleCallback(msg);    
        } else {
            if (mCallback != null) { //判断Handler里的callback是否为空
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg); //调用handlerMessage
        }
    }

```
##### 将Message压入MessageQueue

> 方法

1. post系列
    1. `public final boolean post(Runnable r)`
    2. `public final boolean postAtTime(Runnable r, long uptimeMillis)`
    ...
    

2. Send 系列
     1.     `public final boolean sendEmptyMessage(int what)`
    2.    `public final boolean sendMessage(Message msg)`
    3.     `public final boolean sendMessageDelayed(Message msg, long delayMillis)`
    

> 区别
    
    send方法直接处理的Message对象，post方法需要把其他对象转成message对象再执行下一步。
    
   
## MessageQueue

> 提供新建，元素入队，元素出队，删除元素，销毁队列等方法。

## Looper

> 应用程序使用Looper包括两种情况

1. 主线程（MainThread）
2. 普通线程


```
Looper 构造函数

private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);     // MessageQueue 对象
        mThread = Thread.currentThread();
}
```

```
普通线程中使用Looper

class LooperThread extends Thread{
    public Handler mHandler;
    public void run(){
        Looper.prepare();   // new Looper并new MessageQueue对象，并设置Looper里的mThread为当前Thread
        mHandler = new Handler(){  // 执行myLooper方法获取looper对象赋值给Looper里的mLooper
            public void handleMessage(Message message){
                // 处理消息的地方
            }
        }
        Looper.loop();
    }
}
```


```
Handler 中post Message

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);    // 调用msg的target来处理消息
    }
```


```
Looper.prepare()

 private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));     //只能调用一次，设置Looper 
}
```



```
myLooper 方法

/**
* Return the Looper object associated with the current thread.  Returns
* null if the calling thread is not associated with a Looper.
*/
public static @Nullable Looper myLooper() {
   return sThreadLocal.get();
}
```


```
loop 方法

    /**
     * Run the message queue in this thread. Be sure to call
     * {@link #quit()} to end the loop.
     */
    public static void loop() {
        final Looper me = myLooper();       //获取looper
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;   //获取MessageQueue  

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(">>>>> Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }

            msg.target.dispatchMessage(msg);

            if (logging != null) {
                logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, "Thread identity changed from 0x"
                        + Long.toHexString(ident) + " to 0x"
                        + Long.toHexString(newIdent) + " while dispatching to "
                        + msg.target.getClass().getName() + " "
                        + msg.callback + " what=" + msg.what);
            }

            msg.recycleUnchecked();
        }
    }

```

